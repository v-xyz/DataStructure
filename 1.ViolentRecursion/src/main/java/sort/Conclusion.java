package sort;

public class Conclusion {
    /*
    * 对于[2,2,3,1,4]的排序，假设结果[1,2,2,3,4],
    * 那么原来的第二个 2 的位置不应该发生任何改变。这样的排序叫做具有稳定性。
    * 对于引用类型的数据时，稳定性很关键。
    *
    * 在学过的排序中，
    * 不具备稳定性的有：
    * 1.选择排序。选择最小的放在前面直接破坏了稳定性.
    * 2.快速排序。partition破坏了稳定性。
    * 3.堆排序。不管稳不稳定的情况，只考虑堆结构。
    *
    * 具备稳定性的排序有:
    * 1.冒泡排序。相等时不交换即可保证稳定性。
    * 2.插入排序.同样相等时不改变位置。
    * 3.归并排序。如果先相等时先拷贝左边的，不会破坏。如果先拷贝右边的，会破环。
    * 4.计数和基数排序(桶排序)。
    *
    * 排序算法总结：
    * 1.不基于比较的排序，对样本数据有严格要求，不易改写。
    * 2.基于比较的排序，只要规定好两个样本怎么比大小就可以直接复用。
    * 3.基于比较的排序，时间复杂度极限是 O(N * logN)
    * 4.时间复杂度 O(N * logN),额外空间复杂度低于 O(N),且稳定的基于比较的排序
    *   是不存在的
    * 5.为了绝对的速度选快排，为了省空间选堆排，为了稳定选归并。[快排的常数时间最小]
    *
    * 常见的坑[可以但没必要]：
    * 1.归并排序的额外空间复杂度可以变成 O(1)."归并排序 内部缓存法"，但是将变的不再稳定;[没必要，可以直接用堆]
    * 2."原地归并排序"会让时间复杂度变成 O(N^2),[没必要，还不如直接插排]
    * 3.快速排序稳定性改进，"01 stable sort",但是会对样本数据做出更多要求。[不如桶排序]
    *
    * */
}
